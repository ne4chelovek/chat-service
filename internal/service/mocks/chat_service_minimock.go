// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ne4chelovek/chat_service/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/ne4chelovek/chat_service/internal/model"
	"google.golang.org/protobuf/types/known/emptypb"
)

// ChatServiceMock implements mm_service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnect          func(chatID int64, stream model.Stream, username string) (err error)
	funcConnectOrigin    string
	inspectFuncConnect   func(chatID int64, stream model.Stream, username string)
	afterConnectCounter  uint64
	beforeConnectCounter uint64
	ConnectMock          mChatServiceMockConnect

	funcCreate          func(ctx context.Context, user []string) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, user []string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatServiceMockCreate

	funcDeleteChat          func(ctx context.Context, chatID int64) (ep1 *emptypb.Empty, err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatServiceMockDeleteChat

	funcGetChatInfo          func(ctx context.Context, chatID int64) (sa1 []string, err error)
	funcGetChatInfoOrigin    string
	inspectFuncGetChatInfo   func(ctx context.Context, chatID int64)
	afterGetChatInfoCounter  uint64
	beforeGetChatInfoCounter uint64
	GetChatInfoMock          mChatServiceMockGetChatInfo

	funcGetMessage          func(ctx context.Context, chatID int64, limit uint64, offset uint64) (mpa1 []*model.Message, err error)
	funcGetMessageOrigin    string
	inspectFuncGetMessage   func(ctx context.Context, chatID int64, limit uint64, offset uint64)
	afterGetMessageCounter  uint64
	beforeGetMessageCounter uint64
	GetMessageMock          mChatServiceMockGetMessage

	funcSendMessage          func(ctx context.Context, chatID int64, mes *model.Message) (s1 string, err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, chatID int64, mes *model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for mm_service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectMock = mChatServiceMockConnect{mock: m}
	m.ConnectMock.callArgs = []*ChatServiceMockConnectParams{}

	m.CreateMock = mChatServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatServiceMockCreateParams{}

	m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

	m.GetChatInfoMock = mChatServiceMockGetChatInfo{mock: m}
	m.GetChatInfoMock.callArgs = []*ChatServiceMockGetChatInfoParams{}

	m.GetMessageMock = mChatServiceMockGetMessage{mock: m}
	m.GetMessageMock.callArgs = []*ChatServiceMockGetMessageParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockConnect struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectExpectation
	expectations       []*ChatServiceMockConnectExpectation

	callArgs []*ChatServiceMockConnectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockConnectExpectation specifies expectation struct of the ChatService.Connect
type ChatServiceMockConnectExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockConnectParams
	paramPtrs          *ChatServiceMockConnectParamPtrs
	expectationOrigins ChatServiceMockConnectExpectationOrigins
	results            *ChatServiceMockConnectResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockConnectParams contains parameters of the ChatService.Connect
type ChatServiceMockConnectParams struct {
	chatID   int64
	stream   model.Stream
	username string
}

// ChatServiceMockConnectParamPtrs contains pointers to parameters of the ChatService.Connect
type ChatServiceMockConnectParamPtrs struct {
	chatID   *int64
	stream   *model.Stream
	username *string
}

// ChatServiceMockConnectResults contains results of the ChatService.Connect
type ChatServiceMockConnectResults struct {
	err error
}

// ChatServiceMockConnectOrigins contains origins of expectations of the ChatService.Connect
type ChatServiceMockConnectExpectationOrigins struct {
	origin         string
	originChatID   string
	originStream   string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConnect *mChatServiceMockConnect) Optional() *mChatServiceMockConnect {
	mmConnect.optional = true
	return mmConnect
}

// Expect sets up expected params for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Expect(chatID int64, stream model.Stream, username string) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.paramPtrs != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by ExpectParams functions")
	}

	mmConnect.defaultExpectation.params = &ChatServiceMockConnectParams{chatID, stream, username}
	mmConnect.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConnect.expectations {
		if minimock.Equal(e.params, mmConnect.defaultExpectation.params) {
			mmConnect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnect.defaultExpectation.params)
		}
	}

	return mmConnect
}

// ExpectChatIDParam1 sets up expected param chatID for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) ExpectChatIDParam1(chatID int64) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.params != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Expect")
	}

	if mmConnect.defaultExpectation.paramPtrs == nil {
		mmConnect.defaultExpectation.paramPtrs = &ChatServiceMockConnectParamPtrs{}
	}
	mmConnect.defaultExpectation.paramPtrs.chatID = &chatID
	mmConnect.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmConnect
}

// ExpectStreamParam2 sets up expected param stream for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) ExpectStreamParam2(stream model.Stream) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.params != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Expect")
	}

	if mmConnect.defaultExpectation.paramPtrs == nil {
		mmConnect.defaultExpectation.paramPtrs = &ChatServiceMockConnectParamPtrs{}
	}
	mmConnect.defaultExpectation.paramPtrs.stream = &stream
	mmConnect.defaultExpectation.expectationOrigins.originStream = minimock.CallerInfo(1)

	return mmConnect
}

// ExpectUsernameParam3 sets up expected param username for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) ExpectUsernameParam3(username string) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.params != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Expect")
	}

	if mmConnect.defaultExpectation.paramPtrs == nil {
		mmConnect.defaultExpectation.paramPtrs = &ChatServiceMockConnectParamPtrs{}
	}
	mmConnect.defaultExpectation.paramPtrs.username = &username
	mmConnect.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmConnect
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Inspect(f func(chatID int64, stream model.Stream, username string)) *mChatServiceMockConnect {
	if mmConnect.mock.inspectFuncConnect != nil {
		mmConnect.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Connect")
	}

	mmConnect.mock.inspectFuncConnect = f

	return mmConnect
}

// Return sets up results that will be returned by ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Return(err error) *ChatServiceMock {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{mock: mmConnect.mock}
	}
	mmConnect.defaultExpectation.results = &ChatServiceMockConnectResults{err}
	mmConnect.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConnect.mock
}

// Set uses given function f to mock the ChatService.Connect method
func (mmConnect *mChatServiceMockConnect) Set(f func(chatID int64, stream model.Stream, username string) (err error)) *ChatServiceMock {
	if mmConnect.defaultExpectation != nil {
		mmConnect.mock.t.Fatalf("Default expectation is already set for the ChatService.Connect method")
	}

	if len(mmConnect.expectations) > 0 {
		mmConnect.mock.t.Fatalf("Some expectations are already set for the ChatService.Connect method")
	}

	mmConnect.mock.funcConnect = f
	mmConnect.mock.funcConnectOrigin = minimock.CallerInfo(1)
	return mmConnect.mock
}

// When sets expectation for the ChatService.Connect which will trigger the result defined by the following
// Then helper
func (mmConnect *mChatServiceMockConnect) When(chatID int64, stream model.Stream, username string) *ChatServiceMockConnectExpectation {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectExpectation{
		mock:               mmConnect.mock,
		params:             &ChatServiceMockConnectParams{chatID, stream, username},
		expectationOrigins: ChatServiceMockConnectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConnect.expectations = append(mmConnect.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Connect return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectResults{err}
	return e.mock
}

// Times sets number of times ChatService.Connect should be invoked
func (mmConnect *mChatServiceMockConnect) Times(n uint64) *mChatServiceMockConnect {
	if n == 0 {
		mmConnect.mock.t.Fatalf("Times of ChatServiceMock.Connect mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConnect.expectedInvocations, n)
	mmConnect.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConnect
}

func (mmConnect *mChatServiceMockConnect) invocationsDone() bool {
	if len(mmConnect.expectations) == 0 && mmConnect.defaultExpectation == nil && mmConnect.mock.funcConnect == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConnect.mock.afterConnectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConnect.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Connect implements mm_service.ChatService
func (mmConnect *ChatServiceMock) Connect(chatID int64, stream model.Stream, username string) (err error) {
	mm_atomic.AddUint64(&mmConnect.beforeConnectCounter, 1)
	defer mm_atomic.AddUint64(&mmConnect.afterConnectCounter, 1)

	mmConnect.t.Helper()

	if mmConnect.inspectFuncConnect != nil {
		mmConnect.inspectFuncConnect(chatID, stream, username)
	}

	mm_params := ChatServiceMockConnectParams{chatID, stream, username}

	// Record call args
	mmConnect.ConnectMock.mutex.Lock()
	mmConnect.ConnectMock.callArgs = append(mmConnect.ConnectMock.callArgs, &mm_params)
	mmConnect.ConnectMock.mutex.Unlock()

	for _, e := range mmConnect.ConnectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnect.ConnectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnect.ConnectMock.defaultExpectation.Counter, 1)
		mm_want := mmConnect.ConnectMock.defaultExpectation.params
		mm_want_ptrs := mmConnect.ConnectMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockConnectParams{chatID, stream, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnect.ConnectMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.stream != nil && !minimock.Equal(*mm_want_ptrs.stream, mm_got.stream) {
				mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameter stream, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnect.ConnectMock.defaultExpectation.expectationOrigins.originStream, *mm_want_ptrs.stream, mm_got.stream, minimock.Diff(*mm_want_ptrs.stream, mm_got.stream))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConnect.ConnectMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConnect.ConnectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnect.ConnectMock.defaultExpectation.results
		if mm_results == nil {
			mmConnect.t.Fatal("No results are set for the ChatServiceMock.Connect")
		}
		return (*mm_results).err
	}
	if mmConnect.funcConnect != nil {
		return mmConnect.funcConnect(chatID, stream, username)
	}
	mmConnect.t.Fatalf("Unexpected call to ChatServiceMock.Connect. %v %v %v", chatID, stream, username)
	return
}

// ConnectAfterCounter returns a count of finished ChatServiceMock.Connect invocations
func (mmConnect *ChatServiceMock) ConnectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.afterConnectCounter)
}

// ConnectBeforeCounter returns a count of ChatServiceMock.Connect invocations
func (mmConnect *ChatServiceMock) ConnectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.beforeConnectCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Connect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnect *mChatServiceMockConnect) Calls() []*ChatServiceMockConnectParams {
	mmConnect.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectParams, len(mmConnect.callArgs))
	copy(argCopy, mmConnect.callArgs)

	mmConnect.mutex.RUnlock()

	return argCopy
}

// MinimockConnectDone returns true if the count of the Connect invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectDone() bool {
	if m.ConnectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnectMock.invocationsDone()
}

// MinimockConnectInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectInspect() {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Connect at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConnectCounter := mm_atomic.LoadUint64(&m.afterConnectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && afterConnectCounter < 1 {
		if m.ConnectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.Connect at\n%s", m.ConnectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Connect at\n%s with params: %#v", m.ConnectMock.defaultExpectation.expectationOrigins.origin, *m.ConnectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && afterConnectCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.Connect at\n%s", m.funcConnectOrigin)
	}

	if !m.ConnectMock.invocationsDone() && afterConnectCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Connect at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnectMock.expectedInvocations), m.ConnectMock.expectedInvocationsOrigin, afterConnectCounter)
	}
}

type mChatServiceMockCreate struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateExpectation
	expectations       []*ChatServiceMockCreateExpectation

	callArgs []*ChatServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockCreateExpectation specifies expectation struct of the ChatService.Create
type ChatServiceMockCreateExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockCreateParams
	paramPtrs          *ChatServiceMockCreateParamPtrs
	expectationOrigins ChatServiceMockCreateExpectationOrigins
	results            *ChatServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockCreateParams contains parameters of the ChatService.Create
type ChatServiceMockCreateParams struct {
	ctx  context.Context
	user []string
}

// ChatServiceMockCreateParamPtrs contains pointers to parameters of the ChatService.Create
type ChatServiceMockCreateParamPtrs struct {
	ctx  *context.Context
	user *[]string
}

// ChatServiceMockCreateResults contains results of the ChatService.Create
type ChatServiceMockCreateResults struct {
	i1  int64
	err error
}

// ChatServiceMockCreateOrigins contains origins of expectations of the ChatService.Create
type ChatServiceMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mChatServiceMockCreate) Optional() *mChatServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for ChatService.Create
func (mmCreate *mChatServiceMockCreate) Expect(ctx context.Context, user []string) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ChatServiceMockCreateParams{ctx, user}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.Create
func (mmCreate *mChatServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserParam2 sets up expected param user for ChatService.Create
func (mmCreate *mChatServiceMockCreate) ExpectUserParam2(user []string) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.user = &user
	mmCreate.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Create
func (mmCreate *mChatServiceMockCreate) Inspect(f func(ctx context.Context, user []string)) *mChatServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatService.Create
func (mmCreate *mChatServiceMockCreate) Return(i1 int64, err error) *ChatServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatServiceMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the ChatService.Create method
func (mmCreate *mChatServiceMockCreate) Set(f func(ctx context.Context, user []string) (i1 int64, err error)) *ChatServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatService.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the ChatService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatServiceMockCreate) When(ctx context.Context, user []string) *ChatServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ChatServiceMockCreateParams{ctx, user},
		expectationOrigins: ChatServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Create return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateExpectation) Then(i1 int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times ChatService.Create should be invoked
func (mmCreate *mChatServiceMockCreate) Times(n uint64) *mChatServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ChatServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mChatServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.ChatService
func (mmCreate *ChatServiceMock) Create(ctx context.Context, user []string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, user)
	}

	mm_params := ChatServiceMockCreateParams{ctx, user}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockCreateParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatServiceMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, user)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatServiceMock.Create. %v %v", ctx, user)
	return
}

// CreateAfterCounter returns a count of finished ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatServiceMockCreate) Calls() []*ChatServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mChatServiceMockDeleteChat struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteChatExpectation
	expectations       []*ChatServiceMockDeleteChatExpectation

	callArgs []*ChatServiceMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockDeleteChatParams
	paramPtrs          *ChatServiceMockDeleteChatParamPtrs
	expectationOrigins ChatServiceMockDeleteChatExpectationOrigins
	results            *ChatServiceMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockDeleteChatParamPtrs contains pointers to parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
	ep1 *emptypb.Empty
	err error
}

// ChatServiceMockDeleteChatOrigins contains origins of expectations of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServiceMockDeleteChat) Optional() *mChatServiceMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatServiceMockDeleteChatParams{ctx, chatID}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectChatIDParam2(chatID int64) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatServiceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.chatID = &chatID
	mmDeleteChat.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(ep1 *emptypb.Empty, err error) *ChatServiceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatServiceMockDeleteChatResults{ep1, err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (ep1 *emptypb.Empty, err error)) *ChatServiceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, chatID int64) *ChatServiceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatServiceMockDeleteChatParams{ctx, chatID},
		expectationOrigins: ChatServiceMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(ep1 *emptypb.Empty, err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteChatResults{ep1, err}
	return e.mock
}

// Times sets number of times ChatService.DeleteChat should be invoked
func (mmDeleteChat *mChatServiceMockDeleteChat) Times(n uint64) *mChatServiceMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatServiceMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatServiceMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, chatID int64) (ep1 *emptypb.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatServiceMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockDeleteChatParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatServiceMockGetChatInfo struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetChatInfoExpectation
	expectations       []*ChatServiceMockGetChatInfoExpectation

	callArgs []*ChatServiceMockGetChatInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockGetChatInfoExpectation specifies expectation struct of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockGetChatInfoParams
	paramPtrs          *ChatServiceMockGetChatInfoParamPtrs
	expectationOrigins ChatServiceMockGetChatInfoExpectationOrigins
	results            *ChatServiceMockGetChatInfoResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockGetChatInfoParams contains parameters of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoParams struct {
	ctx    context.Context
	chatID int64
}

// ChatServiceMockGetChatInfoParamPtrs contains pointers to parameters of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatServiceMockGetChatInfoResults contains results of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoResults struct {
	sa1 []string
	err error
}

// ChatServiceMockGetChatInfoOrigins contains origins of expectations of the ChatService.GetChatInfo
type ChatServiceMockGetChatInfoExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Optional() *mChatServiceMockGetChatInfo {
	mmGetChatInfo.optional = true
	return mmGetChatInfo
}

// Expect sets up expected params for ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Expect(ctx context.Context, chatID int64) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{}
	}

	if mmGetChatInfo.defaultExpectation.paramPtrs != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by ExpectParams functions")
	}

	mmGetChatInfo.defaultExpectation.params = &ChatServiceMockGetChatInfoParams{ctx, chatID}
	mmGetChatInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatInfo.expectations {
		if minimock.Equal(e.params, mmGetChatInfo.defaultExpectation.params) {
			mmGetChatInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatInfo.defaultExpectation.params)
		}
	}

	return mmGetChatInfo
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) ExpectCtxParam1(ctx context.Context) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{}
	}

	if mmGetChatInfo.defaultExpectation.params != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Expect")
	}

	if mmGetChatInfo.defaultExpectation.paramPtrs == nil {
		mmGetChatInfo.defaultExpectation.paramPtrs = &ChatServiceMockGetChatInfoParamPtrs{}
	}
	mmGetChatInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatInfo
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) ExpectChatIDParam2(chatID int64) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{}
	}

	if mmGetChatInfo.defaultExpectation.params != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Expect")
	}

	if mmGetChatInfo.defaultExpectation.paramPtrs == nil {
		mmGetChatInfo.defaultExpectation.paramPtrs = &ChatServiceMockGetChatInfoParamPtrs{}
	}
	mmGetChatInfo.defaultExpectation.paramPtrs.chatID = &chatID
	mmGetChatInfo.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmGetChatInfo
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Inspect(f func(ctx context.Context, chatID int64)) *mChatServiceMockGetChatInfo {
	if mmGetChatInfo.mock.inspectFuncGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetChatInfo")
	}

	mmGetChatInfo.mock.inspectFuncGetChatInfo = f

	return mmGetChatInfo
}

// Return sets up results that will be returned by ChatService.GetChatInfo
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Return(sa1 []string, err error) *ChatServiceMock {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	if mmGetChatInfo.defaultExpectation == nil {
		mmGetChatInfo.defaultExpectation = &ChatServiceMockGetChatInfoExpectation{mock: mmGetChatInfo.mock}
	}
	mmGetChatInfo.defaultExpectation.results = &ChatServiceMockGetChatInfoResults{sa1, err}
	mmGetChatInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatInfo.mock
}

// Set uses given function f to mock the ChatService.GetChatInfo method
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Set(f func(ctx context.Context, chatID int64) (sa1 []string, err error)) *ChatServiceMock {
	if mmGetChatInfo.defaultExpectation != nil {
		mmGetChatInfo.mock.t.Fatalf("Default expectation is already set for the ChatService.GetChatInfo method")
	}

	if len(mmGetChatInfo.expectations) > 0 {
		mmGetChatInfo.mock.t.Fatalf("Some expectations are already set for the ChatService.GetChatInfo method")
	}

	mmGetChatInfo.mock.funcGetChatInfo = f
	mmGetChatInfo.mock.funcGetChatInfoOrigin = minimock.CallerInfo(1)
	return mmGetChatInfo.mock
}

// When sets expectation for the ChatService.GetChatInfo which will trigger the result defined by the following
// Then helper
func (mmGetChatInfo *mChatServiceMockGetChatInfo) When(ctx context.Context, chatID int64) *ChatServiceMockGetChatInfoExpectation {
	if mmGetChatInfo.mock.funcGetChatInfo != nil {
		mmGetChatInfo.mock.t.Fatalf("ChatServiceMock.GetChatInfo mock is already set by Set")
	}

	expectation := &ChatServiceMockGetChatInfoExpectation{
		mock:               mmGetChatInfo.mock,
		params:             &ChatServiceMockGetChatInfoParams{ctx, chatID},
		expectationOrigins: ChatServiceMockGetChatInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatInfo.expectations = append(mmGetChatInfo.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetChatInfo return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetChatInfoExpectation) Then(sa1 []string, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetChatInfoResults{sa1, err}
	return e.mock
}

// Times sets number of times ChatService.GetChatInfo should be invoked
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Times(n uint64) *mChatServiceMockGetChatInfo {
	if n == 0 {
		mmGetChatInfo.mock.t.Fatalf("Times of ChatServiceMock.GetChatInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatInfo.expectedInvocations, n)
	mmGetChatInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatInfo
}

func (mmGetChatInfo *mChatServiceMockGetChatInfo) invocationsDone() bool {
	if len(mmGetChatInfo.expectations) == 0 && mmGetChatInfo.defaultExpectation == nil && mmGetChatInfo.mock.funcGetChatInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatInfo.mock.afterGetChatInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatInfo implements mm_service.ChatService
func (mmGetChatInfo *ChatServiceMock) GetChatInfo(ctx context.Context, chatID int64) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetChatInfo.beforeGetChatInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatInfo.afterGetChatInfoCounter, 1)

	mmGetChatInfo.t.Helper()

	if mmGetChatInfo.inspectFuncGetChatInfo != nil {
		mmGetChatInfo.inspectFuncGetChatInfo(ctx, chatID)
	}

	mm_params := ChatServiceMockGetChatInfoParams{ctx, chatID}

	// Record call args
	mmGetChatInfo.GetChatInfoMock.mutex.Lock()
	mmGetChatInfo.GetChatInfoMock.callArgs = append(mmGetChatInfo.GetChatInfoMock.callArgs, &mm_params)
	mmGetChatInfo.GetChatInfoMock.mutex.Unlock()

	for _, e := range mmGetChatInfo.GetChatInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetChatInfo.GetChatInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatInfo.GetChatInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatInfo.GetChatInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatInfo.GetChatInfoMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockGetChatInfoParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatInfo.t.Errorf("ChatServiceMock.GetChatInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatInfo.GetChatInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmGetChatInfo.t.Errorf("ChatServiceMock.GetChatInfo got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatInfo.GetChatInfoMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatInfo.t.Errorf("ChatServiceMock.GetChatInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatInfo.GetChatInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatInfo.GetChatInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatInfo.t.Fatal("No results are set for the ChatServiceMock.GetChatInfo")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetChatInfo.funcGetChatInfo != nil {
		return mmGetChatInfo.funcGetChatInfo(ctx, chatID)
	}
	mmGetChatInfo.t.Fatalf("Unexpected call to ChatServiceMock.GetChatInfo. %v %v", ctx, chatID)
	return
}

// GetChatInfoAfterCounter returns a count of finished ChatServiceMock.GetChatInfo invocations
func (mmGetChatInfo *ChatServiceMock) GetChatInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatInfo.afterGetChatInfoCounter)
}

// GetChatInfoBeforeCounter returns a count of ChatServiceMock.GetChatInfo invocations
func (mmGetChatInfo *ChatServiceMock) GetChatInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatInfo.beforeGetChatInfoCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetChatInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatInfo *mChatServiceMockGetChatInfo) Calls() []*ChatServiceMockGetChatInfoParams {
	mmGetChatInfo.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetChatInfoParams, len(mmGetChatInfo.callArgs))
	copy(argCopy, mmGetChatInfo.callArgs)

	mmGetChatInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatInfoDone returns true if the count of the GetChatInfo invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetChatInfoDone() bool {
	if m.GetChatInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatInfoMock.invocationsDone()
}

// MinimockGetChatInfoInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetChatInfoInspect() {
	for _, e := range m.GetChatInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatInfoCounter := mm_atomic.LoadUint64(&m.afterGetChatInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatInfoMock.defaultExpectation != nil && afterGetChatInfoCounter < 1 {
		if m.GetChatInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s", m.GetChatInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s with params: %#v", m.GetChatInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetChatInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatInfo != nil && afterGetChatInfoCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.GetChatInfo at\n%s", m.funcGetChatInfoOrigin)
	}

	if !m.GetChatInfoMock.invocationsDone() && afterGetChatInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.GetChatInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatInfoMock.expectedInvocations), m.GetChatInfoMock.expectedInvocationsOrigin, afterGetChatInfoCounter)
	}
}

type mChatServiceMockGetMessage struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetMessageExpectation
	expectations       []*ChatServiceMockGetMessageExpectation

	callArgs []*ChatServiceMockGetMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockGetMessageExpectation specifies expectation struct of the ChatService.GetMessage
type ChatServiceMockGetMessageExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockGetMessageParams
	paramPtrs          *ChatServiceMockGetMessageParamPtrs
	expectationOrigins ChatServiceMockGetMessageExpectationOrigins
	results            *ChatServiceMockGetMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockGetMessageParams contains parameters of the ChatService.GetMessage
type ChatServiceMockGetMessageParams struct {
	ctx    context.Context
	chatID int64
	limit  uint64
	offset uint64
}

// ChatServiceMockGetMessageParamPtrs contains pointers to parameters of the ChatService.GetMessage
type ChatServiceMockGetMessageParamPtrs struct {
	ctx    *context.Context
	chatID *int64
	limit  *uint64
	offset *uint64
}

// ChatServiceMockGetMessageResults contains results of the ChatService.GetMessage
type ChatServiceMockGetMessageResults struct {
	mpa1 []*model.Message
	err  error
}

// ChatServiceMockGetMessageOrigins contains origins of expectations of the ChatService.GetMessage
type ChatServiceMockGetMessageExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetMessage *mChatServiceMockGetMessage) Optional() *mChatServiceMockGetMessage {
	mmGetMessage.optional = true
	return mmGetMessage
}

// Expect sets up expected params for ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) Expect(ctx context.Context, chatID int64, limit uint64, offset uint64) *mChatServiceMockGetMessage {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	if mmGetMessage.defaultExpectation == nil {
		mmGetMessage.defaultExpectation = &ChatServiceMockGetMessageExpectation{}
	}

	if mmGetMessage.defaultExpectation.paramPtrs != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by ExpectParams functions")
	}

	mmGetMessage.defaultExpectation.params = &ChatServiceMockGetMessageParams{ctx, chatID, limit, offset}
	mmGetMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetMessage.expectations {
		if minimock.Equal(e.params, mmGetMessage.defaultExpectation.params) {
			mmGetMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMessage.defaultExpectation.params)
		}
	}

	return mmGetMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceMockGetMessage {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	if mmGetMessage.defaultExpectation == nil {
		mmGetMessage.defaultExpectation = &ChatServiceMockGetMessageExpectation{}
	}

	if mmGetMessage.defaultExpectation.params != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Expect")
	}

	if mmGetMessage.defaultExpectation.paramPtrs == nil {
		mmGetMessage.defaultExpectation.paramPtrs = &ChatServiceMockGetMessageParamPtrs{}
	}
	mmGetMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetMessage
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) ExpectChatIDParam2(chatID int64) *mChatServiceMockGetMessage {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	if mmGetMessage.defaultExpectation == nil {
		mmGetMessage.defaultExpectation = &ChatServiceMockGetMessageExpectation{}
	}

	if mmGetMessage.defaultExpectation.params != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Expect")
	}

	if mmGetMessage.defaultExpectation.paramPtrs == nil {
		mmGetMessage.defaultExpectation.paramPtrs = &ChatServiceMockGetMessageParamPtrs{}
	}
	mmGetMessage.defaultExpectation.paramPtrs.chatID = &chatID
	mmGetMessage.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmGetMessage
}

// ExpectLimitParam3 sets up expected param limit for ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) ExpectLimitParam3(limit uint64) *mChatServiceMockGetMessage {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	if mmGetMessage.defaultExpectation == nil {
		mmGetMessage.defaultExpectation = &ChatServiceMockGetMessageExpectation{}
	}

	if mmGetMessage.defaultExpectation.params != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Expect")
	}

	if mmGetMessage.defaultExpectation.paramPtrs == nil {
		mmGetMessage.defaultExpectation.paramPtrs = &ChatServiceMockGetMessageParamPtrs{}
	}
	mmGetMessage.defaultExpectation.paramPtrs.limit = &limit
	mmGetMessage.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetMessage
}

// ExpectOffsetParam4 sets up expected param offset for ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) ExpectOffsetParam4(offset uint64) *mChatServiceMockGetMessage {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	if mmGetMessage.defaultExpectation == nil {
		mmGetMessage.defaultExpectation = &ChatServiceMockGetMessageExpectation{}
	}

	if mmGetMessage.defaultExpectation.params != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Expect")
	}

	if mmGetMessage.defaultExpectation.paramPtrs == nil {
		mmGetMessage.defaultExpectation.paramPtrs = &ChatServiceMockGetMessageParamPtrs{}
	}
	mmGetMessage.defaultExpectation.paramPtrs.offset = &offset
	mmGetMessage.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) Inspect(f func(ctx context.Context, chatID int64, limit uint64, offset uint64)) *mChatServiceMockGetMessage {
	if mmGetMessage.mock.inspectFuncGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetMessage")
	}

	mmGetMessage.mock.inspectFuncGetMessage = f

	return mmGetMessage
}

// Return sets up results that will be returned by ChatService.GetMessage
func (mmGetMessage *mChatServiceMockGetMessage) Return(mpa1 []*model.Message, err error) *ChatServiceMock {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	if mmGetMessage.defaultExpectation == nil {
		mmGetMessage.defaultExpectation = &ChatServiceMockGetMessageExpectation{mock: mmGetMessage.mock}
	}
	mmGetMessage.defaultExpectation.results = &ChatServiceMockGetMessageResults{mpa1, err}
	mmGetMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetMessage.mock
}

// Set uses given function f to mock the ChatService.GetMessage method
func (mmGetMessage *mChatServiceMockGetMessage) Set(f func(ctx context.Context, chatID int64, limit uint64, offset uint64) (mpa1 []*model.Message, err error)) *ChatServiceMock {
	if mmGetMessage.defaultExpectation != nil {
		mmGetMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.GetMessage method")
	}

	if len(mmGetMessage.expectations) > 0 {
		mmGetMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.GetMessage method")
	}

	mmGetMessage.mock.funcGetMessage = f
	mmGetMessage.mock.funcGetMessageOrigin = minimock.CallerInfo(1)
	return mmGetMessage.mock
}

// When sets expectation for the ChatService.GetMessage which will trigger the result defined by the following
// Then helper
func (mmGetMessage *mChatServiceMockGetMessage) When(ctx context.Context, chatID int64, limit uint64, offset uint64) *ChatServiceMockGetMessageExpectation {
	if mmGetMessage.mock.funcGetMessage != nil {
		mmGetMessage.mock.t.Fatalf("ChatServiceMock.GetMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockGetMessageExpectation{
		mock:               mmGetMessage.mock,
		params:             &ChatServiceMockGetMessageParams{ctx, chatID, limit, offset},
		expectationOrigins: ChatServiceMockGetMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetMessage.expectations = append(mmGetMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetMessageExpectation) Then(mpa1 []*model.Message, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetMessageResults{mpa1, err}
	return e.mock
}

// Times sets number of times ChatService.GetMessage should be invoked
func (mmGetMessage *mChatServiceMockGetMessage) Times(n uint64) *mChatServiceMockGetMessage {
	if n == 0 {
		mmGetMessage.mock.t.Fatalf("Times of ChatServiceMock.GetMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetMessage.expectedInvocations, n)
	mmGetMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetMessage
}

func (mmGetMessage *mChatServiceMockGetMessage) invocationsDone() bool {
	if len(mmGetMessage.expectations) == 0 && mmGetMessage.defaultExpectation == nil && mmGetMessage.mock.funcGetMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetMessage.mock.afterGetMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetMessage implements mm_service.ChatService
func (mmGetMessage *ChatServiceMock) GetMessage(ctx context.Context, chatID int64, limit uint64, offset uint64) (mpa1 []*model.Message, err error) {
	mm_atomic.AddUint64(&mmGetMessage.beforeGetMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMessage.afterGetMessageCounter, 1)

	mmGetMessage.t.Helper()

	if mmGetMessage.inspectFuncGetMessage != nil {
		mmGetMessage.inspectFuncGetMessage(ctx, chatID, limit, offset)
	}

	mm_params := ChatServiceMockGetMessageParams{ctx, chatID, limit, offset}

	// Record call args
	mmGetMessage.GetMessageMock.mutex.Lock()
	mmGetMessage.GetMessageMock.callArgs = append(mmGetMessage.GetMessageMock.callArgs, &mm_params)
	mmGetMessage.GetMessageMock.mutex.Unlock()

	for _, e := range mmGetMessage.GetMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.err
		}
	}

	if mmGetMessage.GetMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMessage.GetMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMessage.GetMessageMock.defaultExpectation.params
		mm_want_ptrs := mmGetMessage.GetMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockGetMessageParams{ctx, chatID, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetMessage.t.Errorf("ChatServiceMock.GetMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMessage.GetMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmGetMessage.t.Errorf("ChatServiceMock.GetMessage got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMessage.GetMessageMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetMessage.t.Errorf("ChatServiceMock.GetMessage got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMessage.GetMessageMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetMessage.t.Errorf("ChatServiceMock.GetMessage got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetMessage.GetMessageMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMessage.t.Errorf("ChatServiceMock.GetMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetMessage.GetMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMessage.GetMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMessage.t.Fatal("No results are set for the ChatServiceMock.GetMessage")
		}
		return (*mm_results).mpa1, (*mm_results).err
	}
	if mmGetMessage.funcGetMessage != nil {
		return mmGetMessage.funcGetMessage(ctx, chatID, limit, offset)
	}
	mmGetMessage.t.Fatalf("Unexpected call to ChatServiceMock.GetMessage. %v %v %v %v", ctx, chatID, limit, offset)
	return
}

// GetMessageAfterCounter returns a count of finished ChatServiceMock.GetMessage invocations
func (mmGetMessage *ChatServiceMock) GetMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessage.afterGetMessageCounter)
}

// GetMessageBeforeCounter returns a count of ChatServiceMock.GetMessage invocations
func (mmGetMessage *ChatServiceMock) GetMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMessage.beforeGetMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMessage *mChatServiceMockGetMessage) Calls() []*ChatServiceMockGetMessageParams {
	mmGetMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetMessageParams, len(mmGetMessage.callArgs))
	copy(argCopy, mmGetMessage.callArgs)

	mmGetMessage.mutex.RUnlock()

	return argCopy
}

// MinimockGetMessageDone returns true if the count of the GetMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetMessageDone() bool {
	if m.GetMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMessageMock.invocationsDone()
}

// MinimockGetMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetMessageInspect() {
	for _, e := range m.GetMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetMessageCounter := mm_atomic.LoadUint64(&m.afterGetMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMessageMock.defaultExpectation != nil && afterGetMessageCounter < 1 {
		if m.GetMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.GetMessage at\n%s", m.GetMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetMessage at\n%s with params: %#v", m.GetMessageMock.defaultExpectation.expectationOrigins.origin, *m.GetMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMessage != nil && afterGetMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.GetMessage at\n%s", m.funcGetMessageOrigin)
	}

	if !m.GetMessageMock.invocationsDone() && afterGetMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.GetMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMessageMock.expectedInvocations), m.GetMessageMock.expectedInvocationsOrigin, afterGetMessageCounter)
	}
}

type mChatServiceMockSendMessage struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockSendMessageParams
	paramPtrs          *ChatServiceMockSendMessageParamPtrs
	expectationOrigins ChatServiceMockSendMessageExpectationOrigins
	results            *ChatServiceMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx    context.Context
	chatID int64
	mes    *model.Message
}

// ChatServiceMockSendMessageParamPtrs contains pointers to parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParamPtrs struct {
	ctx    *context.Context
	chatID *int64
	mes    **model.Message
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	s1  string
	err error
}

// ChatServiceMockSendMessageOrigins contains origins of expectations of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
	originMes    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatServiceMockSendMessage) Optional() *mChatServiceMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, chatID int64, mes *model.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, chatID, mes}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectChatIDParam2(chatID int64) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.chatID = &chatID
	mmSendMessage.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectMesParam3 sets up expected param mes for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectMesParam3(mes *model.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.mes = &mes
	mmSendMessage.defaultExpectation.expectationOrigins.originMes = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, chatID int64, mes *model.Message)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(s1 string, err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{s1, err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, chatID int64, mes *model.Message) (s1 string, err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, chatID int64, mes *model.Message) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ChatServiceMockSendMessageParams{ctx, chatID, mes},
		expectationOrigins: ChatServiceMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(s1 string, err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{s1, err}
	return e.mock
}

// Times sets number of times ChatService.SendMessage should be invoked
func (mmSendMessage *mChatServiceMockSendMessage) Times(n uint64) *mChatServiceMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatServiceMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mChatServiceMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, chatID int64, mes *model.Message) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, chatID, mes)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, chatID, mes}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockSendMessageParams{ctx, chatID, mes}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.mes != nil && !minimock.Equal(*mm_want_ptrs.mes, mm_got.mes) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter mes, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originMes, *mm_want_ptrs.mes, mm_got.mes, minimock.Diff(*mm_want_ptrs.mes, mm_got.mes))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, chatID, mes)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v", ctx, chatID, mes)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatInfoInspect()

			m.MinimockGetMessageInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatInfoDone() &&
		m.MinimockGetMessageDone() &&
		m.MinimockSendMessageDone()
}
