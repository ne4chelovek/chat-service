// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ne4chelovek/chat_service/internal/openApi.ApiCat -o api_cat_minimock.go -n ApiCatMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/ne4chelovek/chat_service/internal/model"
)

// ApiCatMock implements mm_openApi.ApiCat
type ApiCatMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCatFact          func() (mp1 *model.Message, err error)
	funcGetCatFactOrigin    string
	inspectFuncGetCatFact   func()
	afterGetCatFactCounter  uint64
	beforeGetCatFactCounter uint64
	GetCatFactMock          mApiCatMockGetCatFact
}

// NewApiCatMock returns a mock for mm_openApi.ApiCat
func NewApiCatMock(t minimock.Tester) *ApiCatMock {
	m := &ApiCatMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCatFactMock = mApiCatMockGetCatFact{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mApiCatMockGetCatFact struct {
	optional           bool
	mock               *ApiCatMock
	defaultExpectation *ApiCatMockGetCatFactExpectation
	expectations       []*ApiCatMockGetCatFactExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ApiCatMockGetCatFactExpectation specifies expectation struct of the ApiCat.GetCatFact
type ApiCatMockGetCatFactExpectation struct {
	mock *ApiCatMock

	results      *ApiCatMockGetCatFactResults
	returnOrigin string
	Counter      uint64
}

// ApiCatMockGetCatFactResults contains results of the ApiCat.GetCatFact
type ApiCatMockGetCatFactResults struct {
	mp1 *model.Message
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCatFact *mApiCatMockGetCatFact) Optional() *mApiCatMockGetCatFact {
	mmGetCatFact.optional = true
	return mmGetCatFact
}

// Expect sets up expected params for ApiCat.GetCatFact
func (mmGetCatFact *mApiCatMockGetCatFact) Expect() *mApiCatMockGetCatFact {
	if mmGetCatFact.mock.funcGetCatFact != nil {
		mmGetCatFact.mock.t.Fatalf("ApiCatMock.GetCatFact mock is already set by Set")
	}

	if mmGetCatFact.defaultExpectation == nil {
		mmGetCatFact.defaultExpectation = &ApiCatMockGetCatFactExpectation{}
	}

	return mmGetCatFact
}

// Inspect accepts an inspector function that has same arguments as the ApiCat.GetCatFact
func (mmGetCatFact *mApiCatMockGetCatFact) Inspect(f func()) *mApiCatMockGetCatFact {
	if mmGetCatFact.mock.inspectFuncGetCatFact != nil {
		mmGetCatFact.mock.t.Fatalf("Inspect function is already set for ApiCatMock.GetCatFact")
	}

	mmGetCatFact.mock.inspectFuncGetCatFact = f

	return mmGetCatFact
}

// Return sets up results that will be returned by ApiCat.GetCatFact
func (mmGetCatFact *mApiCatMockGetCatFact) Return(mp1 *model.Message, err error) *ApiCatMock {
	if mmGetCatFact.mock.funcGetCatFact != nil {
		mmGetCatFact.mock.t.Fatalf("ApiCatMock.GetCatFact mock is already set by Set")
	}

	if mmGetCatFact.defaultExpectation == nil {
		mmGetCatFact.defaultExpectation = &ApiCatMockGetCatFactExpectation{mock: mmGetCatFact.mock}
	}
	mmGetCatFact.defaultExpectation.results = &ApiCatMockGetCatFactResults{mp1, err}
	mmGetCatFact.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCatFact.mock
}

// Set uses given function f to mock the ApiCat.GetCatFact method
func (mmGetCatFact *mApiCatMockGetCatFact) Set(f func() (mp1 *model.Message, err error)) *ApiCatMock {
	if mmGetCatFact.defaultExpectation != nil {
		mmGetCatFact.mock.t.Fatalf("Default expectation is already set for the ApiCat.GetCatFact method")
	}

	if len(mmGetCatFact.expectations) > 0 {
		mmGetCatFact.mock.t.Fatalf("Some expectations are already set for the ApiCat.GetCatFact method")
	}

	mmGetCatFact.mock.funcGetCatFact = f
	mmGetCatFact.mock.funcGetCatFactOrigin = minimock.CallerInfo(1)
	return mmGetCatFact.mock
}

// Times sets number of times ApiCat.GetCatFact should be invoked
func (mmGetCatFact *mApiCatMockGetCatFact) Times(n uint64) *mApiCatMockGetCatFact {
	if n == 0 {
		mmGetCatFact.mock.t.Fatalf("Times of ApiCatMock.GetCatFact mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCatFact.expectedInvocations, n)
	mmGetCatFact.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCatFact
}

func (mmGetCatFact *mApiCatMockGetCatFact) invocationsDone() bool {
	if len(mmGetCatFact.expectations) == 0 && mmGetCatFact.defaultExpectation == nil && mmGetCatFact.mock.funcGetCatFact == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCatFact.mock.afterGetCatFactCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCatFact.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCatFact implements mm_openApi.ApiCat
func (mmGetCatFact *ApiCatMock) GetCatFact() (mp1 *model.Message, err error) {
	mm_atomic.AddUint64(&mmGetCatFact.beforeGetCatFactCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCatFact.afterGetCatFactCounter, 1)

	mmGetCatFact.t.Helper()

	if mmGetCatFact.inspectFuncGetCatFact != nil {
		mmGetCatFact.inspectFuncGetCatFact()
	}

	if mmGetCatFact.GetCatFactMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCatFact.GetCatFactMock.defaultExpectation.Counter, 1)

		mm_results := mmGetCatFact.GetCatFactMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCatFact.t.Fatal("No results are set for the ApiCatMock.GetCatFact")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetCatFact.funcGetCatFact != nil {
		return mmGetCatFact.funcGetCatFact()
	}
	mmGetCatFact.t.Fatalf("Unexpected call to ApiCatMock.GetCatFact.")
	return
}

// GetCatFactAfterCounter returns a count of finished ApiCatMock.GetCatFact invocations
func (mmGetCatFact *ApiCatMock) GetCatFactAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCatFact.afterGetCatFactCounter)
}

// GetCatFactBeforeCounter returns a count of ApiCatMock.GetCatFact invocations
func (mmGetCatFact *ApiCatMock) GetCatFactBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCatFact.beforeGetCatFactCounter)
}

// MinimockGetCatFactDone returns true if the count of the GetCatFact invocations corresponds
// the number of defined expectations
func (m *ApiCatMock) MinimockGetCatFactDone() bool {
	if m.GetCatFactMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCatFactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCatFactMock.invocationsDone()
}

// MinimockGetCatFactInspect logs each unmet expectation
func (m *ApiCatMock) MinimockGetCatFactInspect() {
	for _, e := range m.GetCatFactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ApiCatMock.GetCatFact")
		}
	}

	afterGetCatFactCounter := mm_atomic.LoadUint64(&m.afterGetCatFactCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCatFactMock.defaultExpectation != nil && afterGetCatFactCounter < 1 {
		m.t.Errorf("Expected call to ApiCatMock.GetCatFact at\n%s", m.GetCatFactMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCatFact != nil && afterGetCatFactCounter < 1 {
		m.t.Errorf("Expected call to ApiCatMock.GetCatFact at\n%s", m.funcGetCatFactOrigin)
	}

	if !m.GetCatFactMock.invocationsDone() && afterGetCatFactCounter > 0 {
		m.t.Errorf("Expected %d calls to ApiCatMock.GetCatFact at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCatFactMock.expectedInvocations), m.GetCatFactMock.expectedInvocationsOrigin, afterGetCatFactCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ApiCatMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCatFactInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ApiCatMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ApiCatMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCatFactDone()
}
